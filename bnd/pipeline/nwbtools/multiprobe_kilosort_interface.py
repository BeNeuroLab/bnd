"""
Kilosort utils during nwb conversion
"""

# TODO: Complete


from neuroconv.datainterfaces import KiloSortSortingInterface
from pynwb import NWBFile
import probeinterface as pi


from pathlib import Path

def _try_loading_trajectory_file():
    pass


def _create_channel_map():
    pass


class MultiProbeKiloSortInterface:
    """
    Class for handling multi-probe kilosorted outputs
    """
        
    def __init__(
        self,
        folder_path: Path,
        keep_good_only: bool = False,
        verbose: bool = False,
    ):
        """Multiprobe kilosort interface

        Parameters
        ----------
        folder_path : Path
            path to session
        keep_good_only : bool, optional
            keep or not only units labelled as `good`, by default False
        verbose : bool, optional
            verbosity level, by default False
        """
        self.kilosort_folder_paths = list(Path(folder_path).glob("**/sorter_output"))
        self.probe_names = [
            ks_path.parent.name.split("_")[-1] for ks_path in self.kilosort_folder_paths
        ]

        self.kilosort_interfaces = [
            KiloSortSortingInterface(folder_path, keep_good_only, verbose)
            for folder_path in self.kilosort_folder_paths
        ]

        self.folder_path = Path(folder_path)


    def set_aligned_starting_time(self, aligned_starting_time: float):
        for kilosort_interface in self.kilosort_interfaces:
            kilosort_interface.set_aligned_starting_time(aligned_starting_time)


    def add_probe_information_to_nwb(self, nwbfile: NWBFile) -> None:
        """
        Add probe information stored in SpikeGLX and pinpoint to the nwbfile if available

        Attempts to add the *trajectory.txt file which contains general probe information such as entry
        & tip position, angles (yaw, pitch roll), and pinpoint probe identifier (autogenerated by
        pinpoint). It also attempts to add the information about electrode location stored
        in *channel_map.txt if available. This maps each electrode to a brain region. Returns None
        as it adds information directly to the nwbfile

        Parameters
        ----------
        nwbfile :
            NWBFile handle

        Returns
        -------
        None
        """

        raw_recording_path = Path(str(self.folder_path).replace("processed", "raw"))
        meta_filepaths = list(raw_recording_path.rglob("*/*ap.meta"))

        # Try loading trajectory information from pinpoint
        pinpoint_trajectory_dict = _try_loading_trajectory_file(raw_recording_path)

        # If pinpoint_trajectories is available, load channel map
        channel_map_dict = (
            _create_channel_map(pinpoint_trajectory_dict, raw_recording_path)
            if pinpoint_trajectory_dict is not None
            else None
        )

        for probe_name in self.probe_names:
            # Get meta_file_path for probe_name
            meta_filepath = next(
                (path for path in meta_filepaths if probe_name in str(path)), None
            )

            # Load probe object
            probe = pi.read_spikeglx(meta_filepath)

            if probe.get_shank_count() == 1:  # Set shank ids
                probe.set_shank_ids(np.full((probe.get_contact_count(),), 1))
            else:
                raise NotImplementedError("Multishank probes not yet implemented")

            nwbfile.create_device(
                name=probe_name,
                description=probe.annotations["model_name"],  # Neuropixels 1.0
                manufacturer=probe.annotations["manufacturer"],
            )
            nwbfile.create_electrode_group(
                name=probe_name,
                description=f'{probe.annotations["model_name"]}. Location is the output from '
                f"pinpoint and corresponds to the targeted brain area",
                location=(
                    pinpoint_trajectory_dict[probe_name]
                    if pinpoint_trajectory_dict
                    else "No pinpoint trajectory"
                ),
                device=nwbfile.devices[probe_name],
            )

            for contact_position, contact_id in zip(
                probe.contact_positions, probe.contact_ids
            ):
                x, y = contact_position
                z = 0.0
                contact_id = int(contact_id.split("e")[1:][0])
                if channel_map_dict is not None:
                    contact_location = channel_map_dict[probe_name].area_name[contact_id]
                else:
                    contact_location = "nan"
                nwbfile.add_electrode(
                    group=nwbfile.electrode_groups[probe_name],
                    x=float(x),
                    y=float(y),
                    z=z,
                    id=contact_id,
                    location=contact_location,
                    reference="Local probe reference: Top of the probe",
                    enforce_unique_id=False,
                )
